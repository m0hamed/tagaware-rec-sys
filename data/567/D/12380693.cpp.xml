<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit   revision="0.9.5" language="C++" filename="12380693.cpp"><comment type="line">//Language: GNU C++</comment>


<comment type="block">/*
#pragma comment(linker, "/stack:20000000")
#define _CRT_SECURE_NO_WARNINGS
#include "stdio.h"
#ifndef DEBUG
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;bitset&gt;
#include &lt;map&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;stack&gt;
#include &lt;set&gt;
#include &lt;list&gt;
#include &lt;deque&gt;
#include &lt;functional&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;complex&gt;
#include &lt;numeric&gt;
using namespace std;

double __begin;
#define DTIME(ccc) __begin = clock(); ccc; std::cerr&lt;&lt;"Time of work = "&lt;&lt;(clock()-__begin)/CLOCKS_PER_SEC&lt;&lt;std::endl;

#define mp make_pair
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;long long, long long&gt; pll;
typedef vector&lt;int&gt; vi;
typedef vector&lt;long long&gt; vll;

template&lt;typename T1, typename T2, typename T3&gt;
struct triple{ T1 a; T2 b; T3 c; triple(){}; triple(T1 _a, T2 _b, T3 _c) :a(_a), b(_b), c(_c){} };
#define tri triple&lt;int,int,int&gt;
#define trl triple&lt;ll,ll,ll&gt;
template&lt;typename T1, typename T2, typename T3&gt;
bool operator&lt;(const triple&lt;T1, T2, T3&gt; &amp;t1, const triple&lt;T1, T2, T3&gt; &amp;t2){ if (t1.a != t2.a) return t1.a &lt; t2.a; else return t1.b &lt; t2.b; }
template&lt;typename T1, typename T2, typename T3&gt;
inline std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const triple&lt;T1, T2, T3&gt;&amp; t){ return os &lt;&lt; "(" &lt;&lt; t.a &lt;&lt; ", " &lt;&lt; t.b &lt;&lt; ", " &lt;&lt; t.c &lt;&lt; ")"; }


#define FI(n) for(int i=0;i&lt;n;i++)
#define FI1(n) for(int i=1;i&lt;n;i++)
#define FJ(n) for(int j=0;j&lt;n;j++)
#define FJ1(n) for(int j=1;j&lt;n;j++)
#define FJI for(int j=0;j&lt;i;j++)
#define FJI1 for(int j=1;j&lt;i;j++)
#define FJIE for(int j=0;j&lt;=i;j++)
#define FJIE1 for(int j=1;j&lt;=i;j++)
#define For(i,a,b) for(int i=a;i&lt;b;i++)

// Input macros
#define S(n)                        scanf("%d",&amp;n)
#define SS(n)                       scanf("%s",n)
#define S2(a,b)						scanf("%d%d",&amp;a,&amp;b)
#define Sc(n)                       scanf("%c",&amp;n)
#define Sl(n)                       scanf("%I64d",&amp;n)
#define Sl2(a,b)					scanf("%I64d%I64d",&amp;a,&amp;b)
#define Sf(n)                       scanf("%lf",&amp;n)
#define Sf2(a,b)                    scanf("%lf%lf",&amp;a,&amp;b)

//Output macros
#define Pr(n)                       printf("%d ",n)
#define Prn(n)                      printf("%d\n",n)
#define Prc(n)                      printf("%c",n)
#define Prcn(n)                     printf("%c\n",n)
#define Prl(n)                      printf("%I64d ",n)
#define Prln(n)                     printf("%I64d\n",n)
#define Prf(n)                      printf("%lf ",n)
#define Prfn(n)                     printf("%lf\n",n)
#define Prs(n)                      printf("%s ",n)
#define Prsn(n)                     printf("%s\n",n)

//STL containers
#define foreach(v, c)               for( auto v = (c).begin();  v != (c).end(); ++v)
#define all(a)                      a.begin(), a.end()
#define in(a,b)                     ((b).find(a) != (b).end())
#define in2(a,b)                    (find(all(b),a) != (b).end())
#define pb                          push_back
#define sz(a)                       ((int)(a.size()))
#define svi(vec,n) FI(n) S(vec[y])
#define svl(vec,n) FI(n) Sl(vec[y])
#define IT ::iterator

//int some_primes[10] = {100271, 500179, 1000003, 2000227, 5000321}
//fill char arrays
#define fill(a,v)                    memset(a, v, sizeof (a))

inline int bits_count(int v){ v = v - ((v &gt;&gt; 1) &amp; 0x55555555); v = (v &amp; 0x33333333) + ((v &gt;&gt; 2) &amp; 0x33333333); return((v + (v &gt;&gt; 4) &amp; 0xF0F0F0F) * 0x1010101) &gt;&gt; 24; }
inline int bits_count(ll v){ int t = v &gt;&gt; 32; int p = (v &amp; ((1LL &lt;&lt; 32) - 1)); return bits_count(t) + bits_count(p); }
unsigned int reverse_bits(register unsigned int x){ x = (((x &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((x &amp; 0x55555555) &lt;&lt; 1)); x = (((x &amp; 0xcccccccc) &gt;&gt; 2) | ((x &amp; 0x33333333) &lt;&lt; 2)); x = (((x &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((x &amp; 0x0f0f0f0f) &lt;&lt; 4)); x = (((x &amp; 0xff00ff00) &gt;&gt; 8) | ((x &amp; 0x00ff00ff) &lt;&lt; 8)); return((x &gt;&gt; 16) | (x &lt;&lt; 16)); }
inline int sign(int x){ return (x &gt;&gt; 31) | (-x &gt;&gt; 31); }
inline bool ispow2(int x){ return (x != 0 &amp;&amp; (x&amp;(x - 1)) == 0); }
#define checkbit(n,b)        ( (n &gt;&gt; b) &amp; 1)
#define INDEX(arr,ind)       (lower_bound(all(arr),ind)-arr.begin())
#define sor(a)  sort(all(a))
#define rsor(a) sort(all(a)); reverse(all(a));

//STL output ********************************
template&lt;typename T1, typename T2&gt;inline std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const std::pair&lt;T1, T2&gt;&amp; p){ return os &lt;&lt; "(" &lt;&lt; p.first &lt;&lt; ", " &lt;&lt; p.second &lt;&lt; ")"; }
template&lt;typename T&gt;inline std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const std::vector&lt;T&gt;&amp; v){ bool first = true; os &lt;&lt; "["; for (unsigned int i = 0; i &lt; v.size(); i++){ if (!first)os &lt;&lt; ", "; os &lt;&lt; v[i]; first = false; }return os &lt;&lt; "]"; }
template&lt;typename T&gt;inline std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const std::set&lt;T&gt;&amp;v){ bool first = true; os &lt;&lt; "["; for (typename std::set&lt;T&gt;::const_iterator ii = v.begin(); ii != v.end(); ++ii){ if (!first)os &lt;&lt; ", "; os &lt;&lt; *ii; first = false; }return os &lt;&lt; "]"; }
template&lt;typename T1, typename T2&gt;inline std::ostream &amp;operator &lt;&lt; (std::ostream &amp; os, const std::map&lt;T1, T2&gt;&amp; v){ bool first = true; os &lt;&lt; "["; for (typename std::map&lt;T1, T2&gt;::const_iterator ii = v.begin(); ii != v.end(); ++ii){ if (!first)os &lt;&lt; ", "; os &lt;&lt; *ii; first = false; }return os &lt;&lt; "]"; }
template&lt;typename T, typename T2&gt;void printarray(T  a[], T2 sz, T2 beg = 0){ for (T2 i = beg; i &lt; sz; i++) cout &lt;&lt; a[i] &lt;&lt; " "; cout &lt;&lt; endl; }

#define FREIN(FILE) freopen(FILE,"rt",stdin)
#define FREOUT(FILE) freopen(FILE,"wt",stdout)

#define sqr(x) ((x)*(x))
#define sqrt(x) sqrt(1.0*(x))
#define pow(x,n) pow(1.0*(x),n)

inline ll binpow(ll x, ll n){ ll res = 1; while (n){ if (n &amp; 1)res *= x; x *= x; n &gt;&gt;= 1; }return res; }
inline ll powmod(ll x, ll n, ll _mod){ ll res = 1; while (n){ if (n &amp; 1)res = (res*x) % _mod; x = (x*x) % _mod; n &gt;&gt;= 1; }return res; }
inline ll gcd(ll a, ll b){ ll t; while (b){ a = a%b; t = a; a = b; b = t; }return a; }
inline int gcd(int a, int b){ int t; while (b){ a = a%b; t = a; a = b; b = t; }return a; }
inline ll lcm(int a, int b){ return a / gcd(a, b)*(ll)b; }
inline ll lcm(ll a, ll b){ return a / gcd(a, b)*b; }
inline ll gcd(ll a, ll b, ll c){ return gcd(gcd(a, b), c); }
inline int gcd(int a, int b, int c){ return gcd(gcd(a, b), c); }
inline ll lcm(ll a, ll b, ll c){ return lcm(lcm(a, b), c); }
inline ll lcm(int a, int b, int c){ return lcm(lcm(a, b), (ll)c); }

inline ll max(ll a, ll b){ return (a &gt; b) ? a : b; }
inline int max(int a, int b){ return (a &gt; b) ? a : b; }
inline double max(double a, double b){ return (a &gt; b) ? a : b; }
inline ll max(ll a, ll b, ll c){ return max(a, max(b, c)); }
inline int max(int a, int b, int c){ return max(a, max(b, c)); }
inline double max(double a, double b, double c){ return max(a, max(b, c)); }
inline ll min(ll a, ll b){ return (a &lt; b) ? a : b; }
inline int min(int a, int b){ return (a &lt; b) ? a : b; }
inline double min(double a, double b){ return (a &lt; b) ? a : b; }
inline ll min(ll a, ll b, ll c){ return min(a, min(b, c)); }
inline int min(int a, int b, int c){ return min(a, min(b, c)); }
inline double min(double a, double b, double c){ return min(a, min(b, c)); }

template&lt;class T&gt;
inline void getar(T a, int n, int m){ for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; ++j) { scanf("%d", &amp;a[i][j]); } }
inline void getar(int *a, int n){ for (int ii = 0; ii &lt; n; ii++){ scanf("%d", a + ii); } }
inline void getar(pii *a, int n){ for (int ii = 0; ii &lt; n; ii++){ scanf("%d%d", &amp;a[ii].first, &amp;a[ii].second); } }
inline void getar(ll *a, int n){ for (int ii = 0; ii &lt; n; ii++){ scanf("%I64d", a + ii); } }
template&lt;class T&gt;
inline void cinarr(T a, int n){ for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; }
template &lt;class T&gt;
inline bool scan_d(T &amp;ret) {
   char c; int sgn;
   if(c = getchar(),c == EOF) return 0; //EOF
   while(c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9')) c = getchar();
   sgn = (c == '-') ? -1 : 1;
   ret = (c == '-') ? 0 : (c - '0');
   while(c = getchar(),c &gt;= '0' &amp;&amp; c &lt;= '9') ret = ret * 10 + (c - '0');
   ret *= sgn;
   return 1;
}

inline void out(int x) {
   if(x &gt; 9) out(x / 10);
   putchar(x % 10 + '0');
}
// Useful constants
#define INF			9000000000
#define EPS			(double)1e-9
#define mod			1000000007
#define PI			3.14159265358979
#endif
#define N 200050
#define M 200050
#define maxn 205
#define MOD 1000000000000000007

#define mem(a)  memset(a, 0, sizeof(a))

int k,len,m,n,pri[N],num;
set&lt;pii&gt; myset;
set&lt;pii&gt;::iterator it;
int main()
{
    while(S(n)!=EOF)
    {
        S2(k,len);
        S(m);
        pii tp = mp(1,n);
        myset.insert(tp);
        int ans = -1;
        num = (tp.second - tp.first + 2) / (len + 1);
        bool flag = true;
        FI(m){
            scan_d(pri[i]);
            if(flag){
                it = myset.lower_bound(mp(pri[i],n + 1));
                it --;
                pii p = *it;
                {
                    myset.erase(it);
                    num -= (p.second - p.first + 2) / (len + 1);
                    if(p.first  &lt;= pri[i] - 1){
                        pii tp = mp(p.first,pri[i] - 1);
                        num += (tp.second - tp.first + 2) / (len + 1);
                        myset.insert(tp);
                    }
                    if(pri[i] + 1 &lt;= p.second){
                        pii tp = mp(pri[i] + 1,p.second);
                        num += (tp.second - tp.first + 2) / (len + 1);
                        myset.insert(tp);
                    }
                    if(num &lt; k){
                        ans = i + 1;
                        flag = false;
                    }
                }
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
*/</comment>
<pragma>#<directive>pragma</directive> <name>comment</name><name>(</name><name>linker</name><name>,</name> <literal>"/stack:20000000"</literal><name>)</name></pragma>
<define>#<directive>define</directive> <macro><name>_CRT_SECURE_NO_WARNINGS</name></macro></define>
<include>#<directive>include</directive> <file>"stdio.h"</file></include>
<ifndef>#<directive>ifndef</directive> <name>DEBUG</name></ifndef>
<include>#<directive>include</directive> <file>&lt;iostream&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;cmath&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;algorithm&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;cstdio&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;cstring&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;string&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;cstdlib&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;vector&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;bitset&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;map&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;queue&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;ctime&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;stack&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;set&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;list&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;deque&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;functional&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;sstream&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;fstream&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;complex&gt;</file></include>
<include>#<directive>include</directive> <file>&lt;numeric&gt;</file></include>
<using>using <namespace>namespace <name>std</name>;</namespace></using>

<decl_stmt><decl><type><name>double</name></type> <name>__begin</name></decl>;</decl_stmt>
<define>#<directive>define</directive> <macro><name>DTIME</name><parameter_list>(<parameter><type><name>ccc</name></type></parameter>)</parameter_list></macro> <value>__begin = clock(); ccc; std::cerr&lt;&lt;"Time of work = "&lt;&lt;(clock()-__begin)/CLOCKS_PER_SEC&lt;&lt;std::endl;</value></define>

<define>#<directive>define</directive> <macro><name>mp</name></macro> <value>make_pair</value></define>
<typedef>typedef <type><name>long</name> <name>long</name></type> <name>ll</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>uint</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>ull</name>;</typedef>
<typedef>typedef <type><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>pii</name>;</typedef>
<typedef>typedef <type><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>, <argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>pll</name>;</typedef>
<typedef>typedef <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>vi</name>;</typedef>
<typedef>typedef <type><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>long</name> <name>long</name></expr></argument>&gt;</argument_list></name></type> <name>vll</name>;</typedef>

<struct><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T1</name></parameter>, <parameter><type><name>typename</name></type> <name>T2</name></parameter>, <parameter><type><name>typename</name></type> <name>T3</name></parameter>&gt;</parameter_list></template>
struct <name>triple</name><block>{<public type="default"> <decl_stmt><decl><type><name>T1</name></type> <name>a</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>T2</name></type> <name>b</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>T3</name></type> <name>c</name></decl>;</decl_stmt> <constructor><name>triple</name><parameter_list>()</parameter_list><block>{}</block></constructor><empty_stmt>;</empty_stmt> <constructor><name>triple</name><parameter_list>(<parameter><decl><type><name>T1</name></type> <name>_a</name></decl></parameter>, <parameter><decl><type><name>T2</name></type> <name>_b</name></decl></parameter>, <parameter><decl><type><name>T3</name></type> <name>_c</name></decl></parameter>)</parameter_list> <member_init_list>:<call><name>a</name><argument_list>(<argument><expr><name>_a</name></expr></argument>)</argument_list></call>, <call><name>b</name><argument_list>(<argument><expr><name>_b</name></expr></argument>)</argument_list></call>, <call><name>c</name><argument_list>(<argument><expr><name>_c</name></expr></argument>)</argument_list></call></member_init_list><block>{}</block></constructor> </public>}</block>;</struct>
<define>#<directive>define</directive> <macro><name>tri</name></macro> <value>triple&lt;int,int,int&gt;</value></define>
<define>#<directive>define</directive> <macro><name>trl</name></macro> <value>triple&lt;ll,ll,ll&gt;</value></define>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T1</name></parameter>, <parameter><type><name>typename</name></type> <name>T2</name></parameter>, <parameter><type><name>typename</name></type> <name>T3</name></parameter>&gt;</parameter_list></template>
<type><name>bool</name></type> <name>operator<name>&lt;</name></name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>triple</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>, <argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>triple</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>, <argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>t2</name></decl></parameter>)</parameter_list><block>{ <if>if <condition>(<expr><name><name>t1</name><operator>.</operator><name>a</name></name> <operator>!=</operator> <name><name>t2</name><operator>.</operator><name>a</name></name></expr>)</condition><then> <block type="pseudo"><return>return <expr><name><name>t1</name><operator>.</operator><name>a</name></name> <operator>&lt;</operator> <name><name>t2</name><operator>.</operator><name>a</name></name></expr>;</return></block></then> <else>else <block type="pseudo"><return>return <expr><name><name>t1</name><operator>.</operator><name>b</name></name> <operator>&lt;</operator> <name><name>t2</name><operator>.</operator><name>b</name></name></expr>;</return></block></else></if> }</block></function>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T1</name></parameter>, <parameter><type><name>typename</name></type> <name>T2</name></parameter>, <parameter><type><name>typename</name></type> <name>T3</name></parameter>&gt;</parameter_list></template>
<specifier>inline</specifier> <type><name><name>std</name><operator>::</operator><name>ostream</name></name><modifier>&amp;</modifier></type> <name>operator <name>&lt;&lt;</name></name> <parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>ostream</name></name><modifier>&amp;</modifier></type> <name>os</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>triple</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>, <argument><expr><name>T3</name></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>t</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"("</literal> <operator>&lt;&lt;</operator> <name><name>t</name><operator>.</operator><name>a</name></name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal> <operator>&lt;&lt;</operator> <name><name>t</name><operator>.</operator><name>b</name></name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal> <operator>&lt;&lt;</operator> <name><name>t</name><operator>.</operator><name>c</name></name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</return> }</block></function>


<define>#<directive>define</directive> <macro><name>FI</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro> <value>for(int i=0;i&lt;n;i++)</value></define>
<define>#<directive>define</directive> <macro><name>FI1</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro> <value>for(int i=1;i&lt;n;i++)</value></define>
<define>#<directive>define</directive> <macro><name>FJ</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro> <value>for(int j=0;j&lt;n;j++)</value></define>
<define>#<directive>define</directive> <macro><name>FJ1</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro> <value>for(int j=1;j&lt;n;j++)</value></define>
<define>#<directive>define</directive> <macro><name>FJI</name></macro> <value>for(int j=0;j&lt;i;j++)</value></define>
<define>#<directive>define</directive> <macro><name>FJI1</name></macro> <value>for(int j=1;j&lt;i;j++)</value></define>
<define>#<directive>define</directive> <macro><name>FJIE</name></macro> <value>for(int j=0;j&lt;=i;j++)</value></define>
<define>#<directive>define</directive> <macro><name>FJIE1</name></macro> <value>for(int j=1;j&lt;=i;j++)</value></define>
<define>#<directive>define</directive> <macro><name>For</name><parameter_list>(<parameter><type><name>i</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></macro> <value>for(int i=a;i&lt;b;i++)</value></define>

<comment type="line">// Input macros</comment>
<define>#<directive>define</directive> <macro><name>S</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                        <value>scanf("%d",&amp;n)</value></define>
<define>#<directive>define</directive> <macro><name>SS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                       <value>scanf("%s",n)</value></define>
<define>#<directive>define</directive> <macro><name>S2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></macro>						<value>scanf("%d%d",&amp;a,&amp;b)</value></define>
<define>#<directive>define</directive> <macro><name>Sc</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                       <value>scanf("%c",&amp;n)</value></define>
<define>#<directive>define</directive> <macro><name>Sl</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                       <value>scanf("%I64d",&amp;n)</value></define>
<define>#<directive>define</directive> <macro><name>Sl2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></macro>					<value>scanf("%I64d%I64d",&amp;a,&amp;b)</value></define>
<define>#<directive>define</directive> <macro><name>Sf</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                       <value>scanf("%lf",&amp;n)</value></define>
<define>#<directive>define</directive> <macro><name>Sf2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></macro>                    <value>scanf("%lf%lf",&amp;a,&amp;b)</value></define>

<comment type="line">//Output macros</comment>
<define>#<directive>define</directive> <macro><name>Pr</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                       <value>printf("%d ",n)</value></define>
<define>#<directive>define</directive> <macro><name>Prn</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                      <value>printf("%d\n",n)</value></define>
<define>#<directive>define</directive> <macro><name>Prc</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                      <value>printf("%c",n)</value></define>
<define>#<directive>define</directive> <macro><name>Prcn</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                     <value>printf("%c\n",n)</value></define>
<define>#<directive>define</directive> <macro><name>Prl</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                      <value>printf("%I64d ",n)</value></define>
<define>#<directive>define</directive> <macro><name>Prln</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                     <value>printf("%I64d\n",n)</value></define>
<define>#<directive>define</directive> <macro><name>Prf</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                      <value>printf("%lf ",n)</value></define>
<define>#<directive>define</directive> <macro><name>Prfn</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                     <value>printf("%lf\n",n)</value></define>
<define>#<directive>define</directive> <macro><name>Prs</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                      <value>printf("%s ",n)</value></define>
<define>#<directive>define</directive> <macro><name>Prsn</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></macro>                     <value>printf("%s\n",n)</value></define>

<comment type="line">//STL containers</comment>
<define>#<directive>define</directive> <macro><name>foreach</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></macro>               <value>for( auto v = (c).begin();  v != (c).end(); ++v)</value></define>
<define>#<directive>define</directive> <macro><name>all</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></macro>                      <value>a.begin(), a.end()</value></define>
<define>#<directive>define</directive> <macro><name>in</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></macro>                     <value>((b).find(a) != (b).end())</value></define>
<define>#<directive>define</directive> <macro><name>in2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></macro>                    <value>(find(all(b),a) != (b).end())</value></define>
<define>#<directive>define</directive> <macro><name>pb</name></macro>                          <value>push_back</value></define>
<define>#<directive>define</directive> <macro><name>sz</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></macro>                       <value>((int)(a.size()))</value></define>
<define>#<directive>define</directive> <macro><name>svi</name><parameter_list>(<parameter><type><name>vec</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></macro> <value>FI(n) S(vec[y])</value></define>
<define>#<directive>define</directive> <macro><name>svl</name><parameter_list>(<parameter><type><name>vec</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></macro> <value>FI(n) Sl(vec[y])</value></define>
<define>#<directive>define</directive> <macro><name>IT</name></macro> <value>::iterator</value></define>

<comment type="line">//int some_primes[10] = {100271, 500179, 1000003, 2000227, 5000321}</comment>
<comment type="line">//fill char arrays</comment>
<define>#<directive>define</directive> <macro><name>fill</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></macro>                    <value>memset(a, v, sizeof (a))</value></define>

<function><specifier>inline</specifier> <type><name>int</name></type> <name>bits_count</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{ <expr_stmt><expr><name>v</name> <operator>=</operator> <name>v</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x55555555</literal><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator></expr>;</expr_stmt> <return>return<expr><operator>(</operator><operator>(</operator><name>v</name> <operator>+</operator> <operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xF0F0F0F</literal><operator>)</operator> <operator>*</operator> <literal type="number">0x1010101</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>int</name></type> <name>bits_count</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>v</name></decl></parameter>)</parameter_list><block>{ <decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><operator>(</operator><name>v</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1LL</literal> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt> <return>return <expr><call><name>bits_count</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>bits_count</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><type><name>unsigned</name> <name>int</name></type> <name>reverse_bits</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <name>unsigned</name> <name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{ <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0xaaaaaaaa</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x55555555</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0xcccccccc</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x33333333</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0xf0f0f0f0</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x0f0f0f0f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0xff00ff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x00ff00ff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt> <return>return<expr><operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>int</name></type> <name>sign</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><operator>(</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>-</operator><name>x</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>bool</name></type> <name>ispow2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><operator>(</operator><name>x</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>x</name><operator>&amp;</operator><operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return> }</block></function>
<define>#<directive>define</directive> <macro><name>checkbit</name><parameter_list>(<parameter><type><name>n</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></macro>        <value>( (n &gt;&gt; b) &amp; 1)</value></define>
<define>#<directive>define</directive> <macro><name>INDEX</name><parameter_list>(<parameter><type><name>arr</name></type></parameter>,<parameter><type><name>ind</name></type></parameter>)</parameter_list></macro>       <value>(lower_bound(all(arr),ind)-arr.begin())</value></define>
<define>#<directive>define</directive> <macro><name>sor</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></macro>  <value>sort(all(a))</value></define>
<define>#<directive>define</directive> <macro><name>rsor</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></macro> <value>sort(all(a)); reverse(all(a));</value></define>

<comment type="line">//STL output ********************************</comment>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T1</name></parameter>, <parameter><type><name>typename</name></type> <name>T2</name></parameter>&gt;</parameter_list></template><specifier>inline</specifier> <type><name><name>std</name><operator>::</operator><name>ostream</name></name><modifier>&amp;</modifier></type> <name>operator <name>&lt;&lt;</name></name> <parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>ostream</name></name><modifier>&amp;</modifier></type> <name>os</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name></name><modifier>&amp;</modifier></type> <name>p</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"("</literal> <operator>&lt;&lt;</operator> <name><name>p</name><operator>.</operator><name>first</name></name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal> <operator>&lt;&lt;</operator> <name><name>p</name><operator>.</operator><name>second</name></name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</return> }</block></function>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template><specifier>inline</specifier> <type><name><name>std</name><operator>::</operator><name>ostream</name></name> <modifier>&amp;</modifier></type><name>operator<name>&lt;&lt;</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>ostream</name></name> <modifier>&amp;</modifier></type><name>os</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></name><modifier>&amp;</modifier></type> <name>v</name></decl></parameter>)</parameter_list><block>{ <decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"["</literal></expr>;</expr_stmt> <for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>v</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{ <if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt></block></then></if> <expr_stmt><expr><name>os</name> <operator>&lt;&lt;</operator> <name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt> }</block></for><return>return <expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"]"</literal></expr>;</return> }</block></function>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>&gt;</parameter_list></template><specifier>inline</specifier> <type><name><name>std</name><operator>::</operator><name>ostream</name></name> <modifier>&amp;</modifier></type><name>operator<name>&lt;&lt;</name></name><parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>ostream</name></name> <modifier>&amp;</modifier></type><name>os</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></name><modifier>&amp;</modifier></type><name>v</name></decl></parameter>)</parameter_list><block>{ <decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"["</literal></expr>;</expr_stmt> <for>for <control>(<init><decl><type><name><typename>typename</typename> <name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></name></type> <name>ii</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>ii</name> <operator>!=</operator> <call><name><name>v</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>ii</name></expr></incr>)</control><block>{ <if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt></block></then></if> <expr_stmt><expr><name>os</name> <operator>&lt;&lt;</operator> <operator>*</operator><name>ii</name></expr>;</expr_stmt> <expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt> }</block></for><return>return <expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"]"</literal></expr>;</return> }</block></function>
<function type="operator"><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T1</name></parameter>, <parameter><type><name>typename</name></type> <name>T2</name></parameter>&gt;</parameter_list></template><specifier>inline</specifier> <type><name><name>std</name><operator>::</operator><name>ostream</name></name> <modifier>&amp;</modifier></type><name>operator <name>&lt;&lt;</name></name> <parameter_list>(<parameter><decl><type><name><name>std</name><operator>::</operator><name>ostream</name></name> <modifier>&amp;</modifier></type> <name>os</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name></name><modifier>&amp;</modifier></type> <name>v</name></decl></parameter>)</parameter_list><block>{ <decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><literal type="boolean">true</literal></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"["</literal></expr>;</expr_stmt> <for>for <control>(<init><decl><type><name><typename>typename</typename> <name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>T2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name></name></type> <name>ii</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>ii</name> <operator>!=</operator> <call><name><name>v</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>ii</name></expr></incr>)</control><block>{ <if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt></block></then></if> <expr_stmt><expr><name>os</name> <operator>&lt;&lt;</operator> <operator>*</operator><name>ii</name></expr>;</expr_stmt> <expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="boolean">false</literal></expr>;</expr_stmt> }</block></for><return>return <expr><name>os</name> <operator>&lt;&lt;</operator> <literal type="string">"]"</literal></expr>;</return> }</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>typename</name></type> <name>T</name></parameter>, <parameter><type><name>typename</name></type> <name>T2</name></parameter>&gt;</parameter_list></template><type><name>void</name></type> <name>printarray</name><parameter_list>(<parameter><decl><type><name>T</name></type>  <name><name>a</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>T2</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>T2</name></type> <name>beg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list><block>{ <for>for <control>(<init><decl><type><name>T2</name></type> <name>i</name> <init>= <expr><name>beg</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block type="pseudo"><expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;</expr_stmt></block></for> <expr_stmt><expr><name>cout</name> <operator>&lt;&lt;</operator> <name>endl</name></expr>;</expr_stmt> }</block></function>

<define>#<directive>define</directive> <macro><name>FREIN</name><parameter_list>(<parameter><type><name>FILE</name></type></parameter>)</parameter_list></macro> <value>freopen(FILE,"rt",stdin)</value></define>
<define>#<directive>define</directive> <macro><name>FREOUT</name><parameter_list>(<parameter><type><name>FILE</name></type></parameter>)</parameter_list></macro> <value>freopen(FILE,"wt",stdout)</value></define>

<define>#<directive>define</directive> <macro><name>sqr</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></macro> <value>((x)*(x))</value></define>
<define>#<directive>define</directive> <macro><name>sqrt</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></macro> <value>sqrt(1.0*(x))</value></define>
<define>#<directive>define</directive> <macro><name>pow</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></macro> <value>pow(1.0*(x),n)</value></define>

<function><specifier>inline</specifier> <type><name>ll</name></type> <name>binpow</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{ <decl_stmt><decl><type><name>ll</name></type> <name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <while>while <condition>(<expr><name>n</name></expr>)</condition><block>{ <if>if <condition>(<expr><name>n</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>res</name> <operator>*=</operator> <name>x</name></expr>;</expr_stmt></block></then></if> <expr_stmt><expr><name>x</name> <operator>*=</operator> <name>x</name></expr>;</expr_stmt> <expr_stmt><expr><name>n</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt> }</block></while><return>return <expr><name>res</name></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>ll</name></type> <name>powmod</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>_mod</name></decl></parameter>)</parameter_list><block>{ <decl_stmt><decl><type><name>ll</name></type> <name>res</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <while>while <condition>(<expr><name>n</name></expr>)</condition><block>{ <if>if <condition>(<expr><name>n</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><then><block type="pseudo"><expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>res</name><operator>*</operator><name>x</name><operator>)</operator> <operator>%</operator> <name>_mod</name></expr>;</expr_stmt></block></then></if> <expr_stmt><expr><name>x</name> <operator>=</operator> <operator>(</operator><name>x</name><operator>*</operator><name>x</name><operator>)</operator> <operator>%</operator> <name>_mod</name></expr>;</expr_stmt> <expr_stmt><expr><name>n</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt> }</block></while><return>return <expr><name>res</name></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>ll</name></type> <name>gcd</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{ <decl_stmt><decl><type><name>ll</name></type> <name>t</name></decl>;</decl_stmt> <while>while <condition>(<expr><name>b</name></expr>)</condition><block>{ <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>%</operator><name>b</name></expr>;</expr_stmt> <expr_stmt><expr><name>t</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt> <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt> <expr_stmt><expr><name>b</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt> }</block></while><return>return <expr><name>a</name></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>int</name></type> <name>gcd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{ <decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt> <while>while <condition>(<expr><name>b</name></expr>)</condition><block>{ <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name><operator>%</operator><name>b</name></expr>;</expr_stmt> <expr_stmt><expr><name>t</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt> <expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt> <expr_stmt><expr><name>b</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt> }</block></while><return>return <expr><name>a</name></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>ll</name></type> <name>lcm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><name>a</name> <operator>/</operator> <call><name>gcd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>*</operator><operator>(</operator><name>ll</name><operator>)</operator><name>b</name></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>ll</name></type> <name>lcm</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><name>a</name> <operator>/</operator> <call><name>gcd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>*</operator><name>b</name></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>ll</name></type> <name>gcd</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><call><name>gcd</name><argument_list>(<argument><expr><call><name>gcd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>int</name></type> <name>gcd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><call><name>gcd</name><argument_list>(<argument><expr><call><name>gcd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>ll</name></type> <name>lcm</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><call><name>lcm</name><argument_list>(<argument><expr><call><name>lcm</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>ll</name></type> <name>lcm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><call><name>lcm</name><argument_list>(<argument><expr><call><name>lcm</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>ll</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

<function><specifier>inline</specifier> <type><name>ll</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&gt;</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><name>a</name></expr> </then><else>: <expr><name>b</name></expr></else></ternary></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>int</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&gt;</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><name>a</name></expr> </then><else>: <expr><name>b</name></expr></else></ternary></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>double</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&gt;</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><name>a</name></expr> </then><else>: <expr><name>b</name></expr></else></ternary></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>ll</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><call><name>max</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>max</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>int</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><call><name>max</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>max</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>double</name></type> <name>max</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><call><name>max</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>max</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>ll</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&lt;</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><name>a</name></expr> </then><else>: <expr><name>b</name></expr></else></ternary></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>int</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&lt;</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><name>a</name></expr> </then><else>: <expr><name>b</name></expr></else></ternary></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>double</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&lt;</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><name>a</name></expr> </then><else>: <expr><name>b</name></expr></else></ternary></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>ll</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>ll</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>ll</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><call><name>min</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>min</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>int</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><call><name>min</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>min</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>
<function><specifier>inline</specifier> <type><name>double</name></type> <name>min</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>c</name></decl></parameter>)</parameter_list><block>{ <return>return <expr><call><name>min</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>min</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></function>

<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<specifier>inline</specifier> <type><name>void</name></type> <name>getar</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>m</name></decl></parameter>)</parameter_list><block>{ <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block type="pseudo"><for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>m</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{ <expr_stmt><expr><call><name>scanf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></for></block></for> }</block></function>
<function><specifier>inline</specifier> <type><name>void</name></type> <name>getar</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{ <for>for <control>(<init><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{ <expr_stmt><expr><call><name>scanf</name><argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>a</name> <operator>+</operator> <name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></for> }</block></function>
<function><specifier>inline</specifier> <type><name>void</name></type> <name>getar</name><parameter_list>(<parameter><decl><type><name>pii</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{ <for>for <control>(<init><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{ <expr_stmt><expr><call><name>scanf</name><argument_list>(<argument><expr><literal type="string">"%d%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>first</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><index>[<expr><name>ii</name></expr>]</index></name><operator>.</operator><name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></for> }</block></function>
<function><specifier>inline</specifier> <type><name>void</name></type> <name>getar</name><parameter_list>(<parameter><decl><type><name>ll</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{ <for>for <control>(<init><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control><block>{ <expr_stmt><expr><call><name>scanf</name><argument_list>(<argument><expr><literal type="string">"%I64d"</literal></expr></argument>, <argument><expr><name>a</name> <operator>+</operator> <name>ii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></for> }</block></function>
<function><template>template<parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<specifier>inline</specifier> <type><name>void</name></type> <name>cinarr</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list><block>{ <for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block type="pseudo"><expr_stmt><expr><name>cin</name> <operator>&gt;&gt;</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block></for> }</block></function>
<function><template>template <parameter_list>&lt;<parameter><type><name>class</name></type> <name>T</name></parameter>&gt;</parameter_list></template>
<specifier>inline</specifier> <type><name>bool</name></type> <name>scan_d</name><parameter_list>(<parameter><decl><type><name>T</name> <modifier>&amp;</modifier></type><name>ret</name></decl></parameter>)</parameter_list> <block>{
   <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>int</name></type> <name>sgn</name></decl>;</decl_stmt>
   <if>if<condition>(<expr><name>c</name> <operator>=</operator> <call><name>getchar</name><argument_list>()</argument_list></call></expr><operator>,</operator><expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><then> <block type="pseudo"><return>return <expr><literal type="number">0</literal></expr>;</return></block></then></if> <comment type="line">//EOF</comment>
   <while>while<condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>c</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <name>c</name></expr></argument> &gt;</argument_list></name> <literal type="char">'9'</literal><operator>)</operator></expr>)</condition> <block type="pseudo"><expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getchar</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block></while>
   <expr_stmt><expr><name>sgn</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
   <expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
   <while>while<condition>(<expr><name>c</name> <operator>=</operator> <call><name>getchar</name><argument_list>()</argument_list></call></expr><operator>,</operator><expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block type="pseudo"><expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ret</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block></while>
   <expr_stmt><expr><name>ret</name> <operator>*=</operator> <name>sgn</name></expr>;</expr_stmt>
   <return>return <expr><literal type="number">1</literal></expr>;</return>
}</block></function>

<function><specifier>inline</specifier> <type><name>void</name></type> <name>out</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{
   <if>if<condition>(<expr><name>x</name> <operator>&gt;</operator> <literal type="number">9</literal></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><call><name>out</name><argument_list>(<argument><expr><name>x</name> <operator>/</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block></then></if>
   <expr_stmt><expr><call><name>putchar</name><argument_list>(<argument><expr><name>x</name> <operator>%</operator> <literal type="number">10</literal> <operator>+</operator> <literal type="char">'0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<comment type="line">// Useful constants</comment>
<define>#<directive>define</directive> <macro><name>INF</name></macro>			<value>9000000000</value></define>
<define>#<directive>define</directive> <macro><name>EPS</name></macro>			<value>(double)1e-9</value></define>
<define>#<directive>define</directive> <macro><name>mod</name></macro>			<value>1000000007</value></define>
<define>#<directive>define</directive> <macro><name>PI</name></macro>			<value>3.14159265358979</value></define>
<comment type="line">//*******************************************************************************/</comment>
<endif>#<directive>endif</directive></endif>
<define>#<directive>define</directive> <macro><name>N</name></macro> <value>200050</value></define>
<define>#<directive>define</directive> <macro><name>M</name></macro> <value>200050</value></define>
<define>#<directive>define</directive> <macro><name>maxn</name></macro> <value>205</value></define>
<define>#<directive>define</directive> <macro><name>MOD</name></macro> <value>1000000000000000007</value></define>

<define>#<directive>define</directive> <macro><name>mem</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></macro>  <value>memset(a, 0, sizeof(a))</value></define>

<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>,<decl><type ref="prev"/><name>len</name></decl>,<decl><type ref="prev"/><name>m</name></decl>,<decl><type ref="prev"/><name>n</name></decl>,<decl><type ref="prev"/><name><name>pri</name><index>[<expr><name>N</name></expr>]</index></name></decl>,<decl><type ref="prev"/><name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>pii</name></expr></argument>&gt;</argument_list></name></type> <name>myset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>pii</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></name></type> <name>it</name></decl>;</decl_stmt>
<function><type><name>int</name></type> <name>getNum</name><parameter_list>(<parameter><decl><type><name>pii</name></type> <name>p</name></decl></parameter>)</parameter_list><block>{
    <decl_stmt><decl><type><name>int</name></type> <name>tn</name> <init>= <expr><name><name>p</name><operator>.</operator><name>second</name></name> <operator>-</operator> <name><name>p</name><operator>.</operator><name>first</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><name>tn</name> <operator>/</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ttn</name> <init>= <expr><name>tn</name> <operator>%</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if>if<condition>(<expr><name>ttn</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><then> <block type="pseudo"><expr_stmt><expr><name>s</name> <operator>++</operator></expr>;</expr_stmt></block></then></if>
    <return>return <expr><name>s</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>main</name><parameter_list>()</parameter_list>
<block>{
    <while>while<condition>(<expr><call><name>S</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>!=</operator><name>EOF</name></expr>)</condition>
    <block>{
        <expr_stmt><expr><call><name>S2</name><argument_list>(<argument><expr><name>k</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>FI</name><argument_list>(<argument>m</argument>)</argument_list></macro><block>{
            <expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name><name>pri</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <expr_stmt><expr><call><name><name>myset</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>pii</name></type> <name>tp</name> <init>= <expr><call><name>mp</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>myset</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>getNum</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ans</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <macro><name>FI</name><argument_list>(<argument>m</argument>)</argument_list></macro><block>{
            <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name><name>myset</name><operator>.</operator><name>lower_bound</name></name><argument_list>(<argument><expr><call><name>mp</name><argument_list>(<argument><expr><name><name>pri</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>(<expr><name>it</name> <operator>!=</operator> <call><name><name>myset</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>)</condition><then><block>{
                <expr_stmt><expr><name>it</name> <operator>--</operator></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>pii</name></type> <name>p</name> <init>= <expr><operator>*</operator><name>it</name></expr></init></decl>;</decl_stmt>
                <if>if<condition>(<expr><name><name>pri</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>p</name><operator>.</operator><name>first</name></name> <operator>&amp;&amp;</operator> <name><name>pri</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <name><name>p</name><operator>.</operator><name>second</name></name></expr>)</condition><then><block>{
                    <expr_stmt><expr><call><name><name>myset</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>num</name> <operator>-=</operator> <call><name>getNum</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if<condition>(<expr><name><name>p</name><operator>.</operator><name>first</name></name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name><name>pri</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><then><block>{
                        <decl_stmt><decl><type><name>pii</name></type> <name>tp</name> <init>= <expr><call><name>mp</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>first</name></name></expr></argument>,<argument><expr><name><name>pri</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>num</name> <operator>+=</operator> <call><name>getNum</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>myset</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <if>if<condition>(<expr><name><name>pri</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>&lt;=</operator> <name><name>p</name><operator>.</operator><name>second</name></name></expr>)</condition><then><block>{
                        <decl_stmt><decl><type><name>pii</name></type> <name>tp</name> <init>= <expr><call><name>mp</name><argument_list>(<argument><expr><name><name>pri</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,<argument><expr><name><name>p</name><operator>.</operator><name>second</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name>num</name> <operator>+=</operator> <call><name>getNum</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>myset</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <if>if<condition>(<expr><name>num</name> <operator>&lt;</operator> <name>k</name></expr>)</condition><then><block>{
                        <expr_stmt><expr><name>ans</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></then></if>
            }</block></then></if>
        }</block>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>,<argument><expr><name>ans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
}</block></function>
</unit>
